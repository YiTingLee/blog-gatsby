<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Blog by Eric Lee]]></title><description><![CDATA[Working on modern web and web services]]></description><link>https://yitinglee.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 01 Apr 2022 16:17:09 GMT</lastBuildDate><item><title><![CDATA[Docker Image Minimization]]></title><description><![CDATA[Docker image減肥大作戰!!]]></description><link>https://yitinglee.github.io/posts/docker-image-minimization</link><guid isPermaLink="false">https://yitinglee.github.io/posts/docker-image-minimization</guid><pubDate>Sat, 17 Jul 2021 17:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;介紹&lt;/h2&gt;
&lt;p&gt;在上傳或下載 docker image 的時候，大家或多或少都應該有遇過 Timeout 或是上傳速度很慢等問題，更甚至有時候是把 docker image 拉到 IOT 裝置上面跑，先天條件上機器就無法容納沒減肥過的 docker image，而縮小 docker image 的大小是避免這些問題的方法之一，也是我們今天要做的主要實驗。&lt;/p&gt;
&lt;p&gt;今天的實驗主要是使用 Nest 這個框架建立出來的 service 來做為我們縮小的主要對象。雖然是使用 Nest 作為範例，但這些方法和概念都可以適用在不同的專案上。&lt;/p&gt;
&lt;h2&gt;第一輪: 準備&lt;/h2&gt;
&lt;p&gt;用 Nest 建一個基本的專案吧&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ nest new nest-playground
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我們會得到一個完整 Nest 的 App, 看起會像這樣
&lt;img src=&quot;/images/docker-image-minimization/folder-structure.png&quot; alt=&quot;Folder Structure&quot;&gt;&lt;/p&gt;
&lt;p&gt;接著用最基本的方法包成 docker image 吧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nest-playground 的專案下建立 Dockerfile&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-Dockerfile&quot;&gt;FROM node:12

WORKDIR /app

COPY . .

RUN yarn install

EXPOSE 3000

CMD [&quot;yarn&quot;, &quot;start&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;build docker image 指令如下&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ docker build -t nest-backend .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣 build 出來的 docker-image 總共使用了*&lt;strong&gt;*1.6G**&lt;/strong&gt;，比預想中大很多吧&lt;/p&gt;
&lt;h4&gt;為什麼這麼大?&lt;/h4&gt;
&lt;p&gt;因為我們把整個 repo，node_modules，以及實際 build 出來的 js 都包在這包 image 內了&lt;/p&gt;
&lt;h2&gt;第二輪: 拿掉非必要檔案&lt;/h2&gt;
&lt;h4&gt;那怎麼辦?&lt;/h4&gt;
&lt;p&gt;這邊先把必要的程式留下來，其他非必要的檔案都拿掉，包含 source code，也就是說除了 build 出來的 dist 外其他檔案都不需要存在&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;把 Dockerfile 分成兩個 stage&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stage1 負責 build code&lt;/li&gt;
&lt;li&gt;stage2 則負責把 stage1 build 好的程式 copy 進去 stage2 內然後 run 起來&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;經過這些處理後，stage2(也就最後要 run 起的 image)內只會包含 dist 內容，任何 repo 內的資料都會被留在 stage1 裡面，並不會被放到 stage2 內，實作如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Dockerfile&quot;&gt;# STAGE 1

FROM node:12 AS build

WORKDIR /app

COPY . .

RUN yarn install

CMD [&quot;yarn&quot;, &quot;build:prod&quot;]

# STAGE 2

FROM node:12

WORKDIR /app

COPY --from=build /app/package.json .
COPY --from=build /app/dist ./dist

EXPOSE 3000

CMD [&quot;yarn&quot;, &quot;start:prod&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊為了將 node_modules 內沒使用到的東西拿掉，我們使用了 webpack 來處理，&lt;a href=&quot;https://github.com/YiTingLee/NestAppMinimization/blob/master/webpack.config.js&quot;&gt;Webpack Config&lt;/a&gt;在這邊。&lt;/p&gt;
&lt;p&gt;這樣處理完的 docker image 剩下*&lt;strong&gt;*919MB**&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;感覺還是很大?&lt;/h4&gt;
&lt;h2&gt;第三輪: 使用輕量化的 Node 版本 alpine&lt;/h2&gt;
&lt;p&gt;我們一般使用的 node image 是 Debian based 的，擁有完整的功能，大小約 650MB+，而 alpine 僅有維持運作最基礎的 OS 功能，甚至連 Python/gcc 都沒有，大小約 50MB+。使用輕量化的 node 並不是完全沒有後遺症，輕量化的 image 肯定就是拿掉了許多功能及 module，但在 image size 上是擁有很大的優勢。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Dockerfile&quot;&gt;# STAGE 1

FROM node:12-alpine AS build

WORKDIR /app

COPY . .

RUN yarn install

CMD [&quot;yarn&quot;, &quot;build:prod&quot;]

# STAGE 2

FROM node:12-alpine

WORKDIR /app

COPY --from=build /app/package.json .
COPY --from=build /app/dist ./dist

EXPOSE 3000

CMD [&quot;yarn&quot;, &quot;start:prod&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用輕量版 Node build 完後的總大小是*&lt;strong&gt;*90.5MB**&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;這次的實驗大小的進度分別是 1.6GB -&gt; 919MB -&gt; 90.5MB，總共減少了 17X，當中除了 Dockerfile 在 Stage 上的操作外還有一些 webpack 的使用才能大幅度的減少 image 的大小。&lt;/p&gt;
&lt;p&gt;這邊要再說一次，雖然今天的實驗主要是使用 Nest 這個框架做為我們的主要範例，但這些方法及概念都可以套用到不同的專案上，尤其是 frontend 的專案另外還可以使用 nginx 等輕量化的 web server 作為基底。&lt;/p&gt;
&lt;h2&gt;Source Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/YiTingLee/NestAppMinimization&quot;&gt;https://github.com/YiTingLee/NestAppMinimization&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Database Index]]></title><description><![CDATA[簡單理解Database index]]></description><link>https://yitinglee.github.io/posts/database-index</link><guid isPermaLink="false">https://yitinglee.github.io/posts/database-index</guid><pubDate>Wed, 11 Nov 2020 20:15:00 GMT</pubDate><content:encoded>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;此文章的目的並非讓大家對於Btree有深度了解，而是使用簡單的方式解釋Database Index的基本原理，使得在設計Index的時候有正確的方向。&lt;/p&gt;
&lt;h2&gt;介紹&lt;/h2&gt;
&lt;p&gt;當我們發現資料庫Query速度越來越慢，且已經漸漸地影響到使用者體驗的時候，那就是優化資料庫的最佳時機，而最典型的方法就是加index，但是在設計上如果不理解index的原理而隨便亂加的話，反而會造成整體資料庫效率降低!!&lt;/p&gt;
&lt;p&gt;目前多數的RDBMS的index都是由Btree的方法實作，所以講Database index之前，必須先簡單了解一下Btree的基本特性。&lt;/p&gt;
&lt;h2&gt;Btree&lt;/h2&gt;
&lt;p&gt;這是Btree的基本樣貌:
&lt;img src=&quot;/images/database-index/btree.png&quot; alt=&quot;Btree&quot;&gt;&lt;/p&gt;
&lt;p&gt;Btree共有幾種特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有別於一般二元樹，每個node都能擁有多個Key&lt;/li&gt;
&lt;li&gt;一個node可以擁有K+1個支線(K = Key的數量)&lt;/li&gt;
&lt;li&gt;Key數值必在兩個Parent的Key範圍內(如圖上的56/74都在47及99內)&lt;/li&gt;
&lt;li&gt;Btree為平衡樹且每個葉節點深度必定相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著我們來看一下Search速度上的差異，圖上的例子共有23/44/47等八個數字，若我們用For-loop的方式尋找，最差情況是O(n)&lt;/p&gt;
&lt;p&gt;若我們從Btree的方式搜尋，則最差情況是最深階層數，故為O(log n)&lt;/p&gt;
&lt;h2&gt;Database index&lt;/h2&gt;
&lt;p&gt;其實在使用資料庫的同時，我們已經不知不覺中使用了大量的index，而這個index就是每個Table的Primary Key，接下來我們就用PK來解釋Database的搜尋方式&lt;/p&gt;
&lt;p&gt;首先我們先建立簡單的Table&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;create table test(
    id integer primary key,
    num integer,
    content varchar(40)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;找出目前test table內的index，可以看出Primary Key本身就會被建立成index&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;eric_db=# select * from pg_indexes where tablename = &apos;test&apos;;
 schemaname | tablename |   indexname    | tablespace |                           indexdef

 public     | test      | test_pkey      |            | CREATE UNIQUE INDEX test_pkey ON public.test USING btree (id)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接著我們來討論index與Btree之間的關係&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/database-index/btree-index.png&quot; alt=&quot;Btree-index&quot;&gt;&lt;/p&gt;
&lt;p&gt;圖中所有的Key都是test中的id(PK)，而在葉節點的部分才會帶該筆id的資料內容。&lt;/p&gt;
&lt;h3&gt;Query&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;select * from test where id = 29;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/images/database-index/btree-index-step.png&quot; alt=&quot;Steps&quot;&gt;&lt;/p&gt;
&lt;p&gt;當我們下Query時，Database找出id為29的方式如圖上所示，且與Btree的走訪方法相同，這邊我就不重複解釋。比較不同的是資料僅存在於葉節點，走訪的過程即便是遇到Key相同只要不在葉節點就無法取得資料。&lt;/p&gt;
&lt;h3&gt;那假設我們是找num = 29的時候也是照著Btree的方法?&lt;/h3&gt;
&lt;p&gt;答案是否定的，只要沒設index，Database就會用full scan的方式去搜尋。&lt;/p&gt;
&lt;h2&gt;原理&lt;/h2&gt;
&lt;p&gt;每當我們建立index時，Database都會幫我們建立一個index table去維護這個Btree，所以index越多則index table當然也越來越多，所需要的空間需求也會隨之增加。&lt;/p&gt;
&lt;p&gt;當我們建立Primary Key以外的index時，基本上原理都是相同的，差別只在於非PK的Btree葉節點的資料內容為PK。&lt;/p&gt;
&lt;p&gt;接著上面的範例，我們設了num為index，然後找出num = 29，Database動作如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;透過num的btree找出id&lt;/li&gt;
&lt;li&gt;再由id的btree找出整個row的內容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;我的硬碟就是大，那我每個欄位都設index來加速好了&lt;/h3&gt;
&lt;p&gt;上面有提到Database會幫我們維護所有的index btree，若index太多會造成新增或刪除資料的時候負擔太大，同時維護多個Btree(包括這些index table的讀寫動作)所造成的負擔都會使你的系統效能變差。&lt;/p&gt;
&lt;h2&gt;實驗&lt;/h2&gt;
&lt;p&gt;隨機建立100萬份資料&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;create table test(
    id integer primary key,
    num integer,
    content varchar(40)
);

create index test_num_index on test(num);

insert into test SELECT generate_series(1,1000000) as id, (random()*(10^3))::integer, (random()*(10^3))::VARCHAR(40);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若沒有postgres的環境的話，可以用docker-compose來玩，這邊是我實驗的環境&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-docker&quot;&gt;version: &quot;3.3&quot;
services:
  postgres:
    image: postgres:latest
    container_name: eric_db
    ports:
      - 5432:5432
    environment: 
      POSTGRES_DB: eric_db
      POSTGRES_USER: eric
      POSTGRES_PASSWORD: eric
    volumes:
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;explain是postgres提供出來查詢sql command的成本，我們就用此方法來實驗&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;eric_db=# explain select * from test where content = &apos;29&apos;;
                               QUERY PLAN
 Gather  (cost=1000.00..13561.43 rows=1 width=26)
   Workers Planned: 2
   -&gt;  Parallel Seq Scan on test  (cost=0.00..12561.33 rows=1 width=26)
         Filter: ((content)::text = &apos;29&apos;::text)
(4 rows)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;eric_db=# explain select * from test where id = 29;
                              QUERY PLAN

 Index Scan using test_pkey on test  (cost=0.42..8.44 rows=1 width=26)
   Index Cond: (id = 29)
(2 rows)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若未使用index的情況下成本為13561.43，這邊Postgres已經幫我們使用了並行處裡，否則成本會更高。反觀使用index的總成本只需要8.44&lt;/p&gt;
&lt;p&gt;這邊我就不解釋此成本的計算方式，簡單理解成數值越高成本越大即可，有興趣者可前往postgres的document。&lt;/p&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;index是非常典型的以空間換取時間的例子，但也不是index越多越好，而是必須透過實際情況來決定哪些column該設定index，都沒用到的column設定index也是很浪費的。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Decorator Pattern]]></title><description><![CDATA[簡單的飲料例子來解釋Decorator]]></description><link>https://yitinglee.github.io/posts/design-pattern-decorator-pattern</link><guid isPermaLink="false">https://yitinglee.github.io/posts/design-pattern-decorator-pattern</guid><pubDate>Sat, 07 Nov 2020 23:15:00 GMT</pubDate><content:encoded>&lt;h2&gt;介紹&lt;/h2&gt;
&lt;p&gt;現在手搖飲料店開得越來越多，能夠點的手搖種類也相當多元，比方說綠茶珍珠、珍珠奶茶、椰果奶茶、仙草奶綠等等，每種配料都能隨意組合，所以 Post 機上的飲料管理肯定相當複雜，這種情況就非常適合使用裝飾者模式來處理。&lt;/p&gt;
&lt;p&gt;若是直接硬幹的話，通常 Class 會長成 MilkTea、BubbleMilkTea 和 BubbleMilkGreenTea 等等，也就是說只要一種配料搭配一種茶類就必須多一個 Class。再來如果要兩倍珍珠的話，這設計方式只能在遇到需求的時候請程式設計師再加一個 Class，這種設計方式顯然是不好的。&lt;/p&gt;
&lt;p&gt;簡單來說，裝飾者模式把上述配料當作裝飾者，而茶類的本體作為被裝飾者，可以想像成被裝飾者還是飲料的主體，而裝飾者只是在被裝飾者的身上加了某些效果及行為。&lt;/p&gt;
&lt;h2&gt;例子&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;我們模擬上面的例子&lt;/li&gt;
&lt;li&gt;被裝飾者抽象類別: Beverage&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;abstract class Beverage {
  description!: string;

  abstract getCost(): number;

  getDescription(): string {
    return this.description;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;各種飲料的實現&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;class MilkTea extends Beverage {
  constructor() {
    super();
    this.description = &quot;Milk Tea&quot;;
  }

  getCost() {
    return 50;
  }
}

class GreenTea extends Beverage {
  constructor() {
    super();
    this.description = &quot;Green Tea&quot;;
  }

  getCost() {
    return 40;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;裝飾者抽象類別: CondimentDecorator&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;abstract class CondimentDecorator extends Beverage {
  abstract getCost(): number;
  abstract getDescription(): string;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;這邊我解釋一下為甚麼&lt;code&gt;getCost&lt;/code&gt;和&lt;code&gt;getDescription&lt;/code&gt;這兩個方法都必須被重新覆寫&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;裝飾者的主要運作方式是在被裝飾者的前後增加某種行為或效果，由下方的 implement 可以看出覆寫後對&lt;code&gt;getCost&lt;/code&gt;和&lt;code&gt;getDescription&lt;/code&gt;增加的行為。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;各種裝飾者的實現&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;class Bubble extends CondimentDecorator {
  private beverage: Beverage;

  constructor(beverage: Beverage) {
    super();
    this.beverage = beverage;
  }

  getDescription() {
    return this.beverage.getDescription() + &apos;, Bubble&apos;;
  }

  getCost() {
    return this.beverage.getCost() + 10;
  }
}

class Pudding extends CondimentDecorator {
  private beverage: Beverage;

  constructor(beverage: Beverage) {
    super();
    this.beverage = beverage;
  }

  getDescription() {
    return this.beverage.getDescription() + &apos;, Pudding&apos;;
  }

  getCost() {
    return this.beverage.getCost() + 20;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;到目前為止我們主要實現了兩個 GreenTea, MilkTea 這兩個被裝飾者 Class, 和 Bubble, Pudding 兩個裝飾者的 Class。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Main&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;console.log(&quot;Start&quot;);
const beverage = new MilkTea();
console.log(beverage.getDescription());
console.log(beverage.getCost());

const bubbleMilkTea = new Bubble(new MilkTea());
console.log(bubbleMilkTea.getDescription());
console.log(bubbleMilkTea.getCost());

const powerTea = new Pudding(new Bubble(new Bubble(new MilkTea())));
console.log(powerTea.getDescription());
console.log(powerTea.getCost());
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Result&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;TypeScript v3.3.3 Node.js v10 linux/amd64
Start
Milk Tea
50
Milk Tea, Bubble
60
Milk Tea, Bubble, Bubble, Pudding
90
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;可以由 Main 程式中看出裝飾者與被裝飾者如何合作&lt;/li&gt;
&lt;li&gt;裝飾者做的事就是直接在被裝飾者身上加行為(不管裝飾者現在到底長怎樣)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;優點&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;高彈性&lt;/li&gt;
&lt;li&gt;達到物件與物件間鬆綁的效果&lt;/li&gt;
&lt;li&gt;於程式執行期中使用合成來達到效果，而非編譯期達成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;缺點&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;裝飾者的小類別會非常多&lt;/li&gt;
&lt;li&gt;初學者會認為相對複雜，容易迷失在物件與物件之間的關係。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;裝飾者模式的優缺點都相對明顯，若使用不當容易造成程式複雜且難以維護，但許多的程式 Library 中都能夠看到使用裝飾者模式的身影。&lt;/p&gt;
&lt;h3&gt;Source Code&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/YiTingLee/Design-Pattern/blob/main/decorator-pattern/index.ts&quot;&gt;https://github.com/YiTingLee/Design-Pattern/blob/main/decorator-pattern/index.ts&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Observer Pattern]]></title><description><![CDATA[Rxjs是什麼設計模式?]]></description><link>https://yitinglee.github.io/posts/design-pattern-observer-pattern</link><guid isPermaLink="false">https://yitinglee.github.io/posts/design-pattern-observer-pattern</guid><pubDate>Thu, 08 Oct 2020 14:35:00 GMT</pubDate><content:encoded>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;觀察者模式大家應該都不太陌生, 很多程式語言都已經有interface或是已經實踐observable的class了, 例如Java和javascript中的Rxjs等等。&lt;/p&gt;
&lt;h2&gt;介紹&lt;/h2&gt;
&lt;p&gt;我們用現在最流行的Youtube來解釋觀察者模式，Youtube上的訂閱方式如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;觀眾對喜歡的youtuber按下訂閱按鈕&lt;/li&gt;
&lt;li&gt;當youtuber有新影片上架時，會主動通知有訂閱的觀眾&lt;/li&gt;
&lt;li&gt;一位youtuber可以同時被多位觀眾訂閱&lt;/li&gt;
&lt;li&gt;觀眾能隨時取消訂閱，也就不會收到youtuber的新影片通知&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;例子&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;我們模擬上面的例子&lt;/li&gt;
&lt;li&gt;Subject interface&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;interface Subject {
  registerObserver(observer: Observer): void;
  removeObserver(observer: Observer):void;
  notifyObservers():void;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Observer&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;interface Observer {
  update(newVideo: object): void;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Video: 這邊只是簡單寫個title&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;interface Video {
  title: string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Youtuber&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;class Youtuber implements Subject {
  observers: Array&amp;#x3C;Observer&gt;;
  video: Video;

  constructor() {
    this.observers = [];
    this.video = { title: &apos;init&apos; };
  }

  registerObserver(observer: Observer) {
    this.observers.push(observer);
  }

  removeObserver(observer: Observer) {
    const index = this.observers.indexOf(observer);
    this.observers = this.observers.splice(index, 1);
  }

  notifyObservers() {
    this.observers.forEach(observer =&gt; {
      observer.update(this.video);
    });
  }

  setVideo() {
    this.video = { title: new Date().getTime().toString()};
    this.notifyObservers();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;User&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;class User implements Observer {
  subject: Subject;
  constructor(subject: Subject) {
    this.subject = subject;
    this.subject.registerObserver(this);
  }

  update(video: Video) {
    this.display(video);
  }

  unsubscribe() {
    this.subject.removeObserver(this);
  }

  display(video: Video) {
    console.log(&apos;video:&apos; + video.title);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Main&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const youtuber = new Youtuber();
const user = new User(youtuber);
const user2 = new User(youtuber);
const user3 = new User(youtuber);
youtuber.setVideo();

user2.unsubscribe();
console.log(&apos;user2 unsubscribe&apos;);
user3.unsubscribe();
console.log(&apos;user3 unsubscribe&apos;);
youtuber.setVideo();
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Result&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;TypeScript v3.3.3 linux/amd64
video:1563710179580
video:1563710179580
video:1563710179580
user2 unsubscribe
user3 unsubscribe
video:1563710179581
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;可以由結果看到一開始使用者都訂閱了youtuber, 所以當youtuber上架新影片時(&lt;code&gt;youtuber.setVideo()&lt;/code&gt;), 三個user都收到了通知(&lt;code&gt;video:1563710179580&lt;/code&gt;), 接著user2, user3退訂了之後, youtuber就只發通知給訂閱中(沒退訂)的user而已&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;優點&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;完美的切割程式碼中會變動的部分，將固定與會變動的部分分開&lt;/li&gt;
&lt;li&gt;定義了通知的傳遞機制&lt;/li&gt;
&lt;li&gt;讓物件與物件間達到鬆散 (loose coupling)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;我們這次介紹的是Push Model，另外還有Pull Model下次有時間再介紹，但基本上概念是相同的，差別僅在於Observer讀取的方式而已。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Source Code&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/YiTingLee/Design-Pattern/blob/main/observer-pattern/index.ts&quot;&gt;https://github.com/YiTingLee/Design-Pattern/blob/main/observer-pattern/index.ts&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Strategy Pattern]]></title><description><![CDATA[使用javascript學習Design Pattern的第一篇 - Strategy Pattern]]></description><link>https://yitinglee.github.io/posts/design-pattern-strategy-pattern</link><guid isPermaLink="false">https://yitinglee.github.io/posts/design-pattern-strategy-pattern</guid><pubDate>Thu, 01 Oct 2020 21:11:00 GMT</pubDate><content:encoded>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;這是Design Pattern這系列的第一篇文章。&lt;/p&gt;
&lt;h2&gt;介紹&lt;/h2&gt;
&lt;p&gt;簡單來說策略模式就是把程式行為中，針對 &quot;實踐&quot; 行為(大部分的情況是相同目的的演算法)加以封裝，讓不同的行為各自繼承並實現，讓使用此行為的物件能夠自由切換。&lt;/p&gt;
&lt;h2&gt;優點&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;無論修改演算法或主程式，都不會互相造成影響&lt;/li&gt;
&lt;li&gt;可以靈活的切換不同的演算法&lt;/li&gt;
&lt;li&gt;良好水平擴充性&lt;/li&gt;
&lt;li&gt;能夠單純進行演算法的測試&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;缺點&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大量的行為類別&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;例子&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;設計跑車、腳踏車、玩具車的加速行為&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;未使用策略模式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;    class Car {
        private mode;
        accelerate() {
            if (mode === &apos;SportCar&apos;) {
                console.log(&apos;引擎驅動&apos;); // 可能會包成function
            } else if (mode === &apos;bicycle&apos;) {
                console.log(&apos;人力驅動&apos;);
            } else if (mode === &apos;toy car&apos;) {
                concole.log(&apos;電池驅動&apos;);
            }
        }
    }
    
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;策略模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;把加速行為封裝成介面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;interface AccelerateBehavior {
    accelerate();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;實現各行為&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class AccelerateWithEngine implements AccelerateBehavior {
    accelerate() {
        console.log(&apos;引擎驅動&apos;);
    }
}

class AccelerateWithPerson implements AccelerateBehavior {
    accelerate() {
        console.log(&apos;人力驅動&apos;);
    }
}

class AccelerateWithBattery implements AccelerateBehavior {
    accelerate() {
        console.log(&apos;電池驅動&apos;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完成最後的Car及使用範例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Car {
    accelerateBehavior: AccelerateBehavior;
    
    constructor(accelerateBehavior) {
        this.setAccelerateBehavior(accelerateBehavior);
    }
    
    setAccelerateBehavior(accelerateBehavior) {
        this.accelerateBehavior = accelerateBehavior;
    }
    
    accelerate() {
        this.accelerateBehavior.accelerate();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const car = new Car(new AccelerateWithEngine());
car.accelerate(); // 引擎驅動
car.setAccelerateBehavior(new AccelerateWithBattery());
car.accelerate(); // 電池驅動
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;結論&lt;/h2&gt;
&lt;p&gt;由策略模式設計出的物件擁有動態切換加速方式的靈活性，在測試方面也能直接對於加速演算法進行測試，可以避免因為if else造成同一個method越來越大包的問題。假設今天要加入不同的加速方式，只需要擴充加速的Class即可，並不會對原有程式造成任何影響。&lt;/p&gt;
&lt;h3&gt;Source Code&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/YiTingLee/Design-Pattern/blob/main/strategy-pattern/index.ts&quot;&gt;https://github.com/YiTingLee/Design-Pattern/blob/main/strategy-pattern/index.ts&lt;/a&gt;&lt;/p&gt;</content:encoded></item></channel></rss>