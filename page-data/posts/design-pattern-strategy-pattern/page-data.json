{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/design-pattern-strategy-pattern","result":{"data":{"markdownRemark":{"id":"e385d441-0249-5174-876e-c5780e60cb4b","html":"<h2>前言</h2>\n<p>這是Design Pattern這系列的第一篇文章。</p>\n<h2>介紹</h2>\n<p>簡單來說策略模式就是把程式行為中，針對 \"實踐\" 行為(大部分的情況是相同目的的演算法)加以封裝，讓不同的行為各自繼承並實現，讓使用此行為的物件能夠自由切換。</p>\n<h2>優點</h2>\n<ul>\n<li>無論修改演算法或主程式，都不會互相造成影響</li>\n<li>可以靈活的切換不同的演算法</li>\n<li>良好水平擴充性</li>\n<li>能夠單純進行演算法的測試</li>\n</ul>\n<h2>缺點</h2>\n<ul>\n<li>大量的行為類別</li>\n</ul>\n<h2>例子</h2>\n<ul>\n<li>設計跑車、腳踏車、玩具車的加速行為</li>\n</ul>\n<h3>未使用策略模式</h3>\n<pre><code class=\"language-javascript\">    class Car {\n        private mode;\n        accelerate() {\n            if (mode === 'SportCar') {\n                console.log('引擎驅動'); // 可能會包成function\n            } else if (mode === 'bicycle') {\n                console.log('人力驅動');\n            } else if (mode === 'toy car') {\n                concole.log('電池驅動');\n            }\n        }\n    }\n    \n</code></pre>\n<h3>策略模式</h3>\n<ul>\n<li>\n<p>把加速行為封裝成介面</p>\n<pre><code class=\"language-javascript\">interface AccelerateBehavior {\n    accelerate();\n}\n</code></pre>\n</li>\n<li>\n<p>實現各行為</p>\n<pre><code class=\"language-javascript\">class AccelerateWithEngine implements AccelerateBehavior {\n    accelerate() {\n        console.log('引擎驅動');\n    }\n}\n\nclass AccelerateWithPerson implements AccelerateBehavior {\n    accelerate() {\n        console.log('人力驅動');\n    }\n}\n\nclass AccelerateWithBattery implements AccelerateBehavior {\n    accelerate() {\n        console.log('電池驅動');\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>完成最後的Car及使用範例</p>\n<pre><code class=\"language-javascript\">class Car {\n    accelerateBehavior: AccelerateBehavior;\n    \n    constructor(accelerateBehavior) {\n        this.setAccelerateBehavior(accelerateBehavior);\n    }\n    \n    setAccelerateBehavior(accelerateBehavior) {\n        this.accelerateBehavior = accelerateBehavior;\n    }\n    \n    accelerate() {\n        this.accelerateBehavior.accelerate();\n    }\n}\n</code></pre>\n<pre><code class=\"language-javascript\">const car = new Car(new AccelerateWithEngine());\ncar.accelerate(); // 引擎驅動\ncar.setAccelerateBehavior(new AccelerateWithBattery());\ncar.accelerate(); // 電池驅動\n</code></pre>\n</li>\n</ul>\n<h2>結論</h2>\n<p>由策略模式設計出的物件擁有動態切換加速方式的靈活性，在測試方面也能直接對於加速演算法進行測試，可以避免因為if else造成同一個method越來越大包的問題。假設今天要加入不同的加速方式，只需要擴充加速的Class即可，並不會對原有程式造成任何影響。</p>\n<h3>Source Code</h3>\n<p><a href=\"https://github.com/YiTingLee/Design-Pattern/blob/main/strategy-pattern/index.ts\">https://github.com/YiTingLee/Design-Pattern/blob/main/strategy-pattern/index.ts</a></p>","fields":{"slug":"/posts/design-pattern-strategy-pattern","tagSlugs":["/tag/design-pattern/"],"readingTime":{"text":"3 min read"}},"frontmatter":{"date":"2020-10-01T21:11:00.000Z","description":"使用javascript學習Design Pattern的第一篇 - Strategy Pattern","tags":["Design Pattern"],"title":"Strategy Pattern","socialImage":""}}},"pageContext":{"slug":"/posts/design-pattern-strategy-pattern"}},"staticQueryHashes":["251939775","3688386433","401334301"]}