{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/design-pattern-observer-pattern","result":{"data":{"markdownRemark":{"id":"4b508be0-f214-5ce0-a22c-324be0c58336","html":"<h2>前言</h2>\n<p>觀察者模式大家應該都不太陌生, 很多程式語言都已經有interface或是已經實踐observable的class了, 例如Java和javascript中的Rxjs等等。</p>\n<h2>介紹</h2>\n<p>我們用現在最流行的Youtube來解釋觀察者模式，Youtube上的訂閱方式如下</p>\n<ul>\n<li>觀眾對喜歡的youtuber按下訂閱按鈕</li>\n<li>當youtuber有新影片上架時，會主動通知有訂閱的觀眾</li>\n<li>一位youtuber可以同時被多位觀眾訂閱</li>\n<li>觀眾能隨時取消訂閱，也就不會收到youtuber的新影片通知</li>\n</ul>\n<h2>例子</h2>\n<ul>\n<li>我們模擬上面的例子</li>\n<li>Subject interface</li>\n</ul>\n<pre><code class=\"language-typescript\">interface Subject {\n  registerObserver(observer: Observer): void;\n  removeObserver(observer: Observer):void;\n  notifyObservers():void;\n}\n</code></pre>\n<ul>\n<li>Observer</li>\n</ul>\n<pre><code class=\"language-typescript\">interface Observer {\n  update(newVideo: object): void;\n}\n</code></pre>\n<ul>\n<li>Video: 這邊只是簡單寫個title</li>\n</ul>\n<pre><code class=\"language-typescript\">interface Video {\n  title: string\n}\n</code></pre>\n<ul>\n<li>Youtuber</li>\n</ul>\n<pre><code class=\"language-typescript\">class Youtuber implements Subject {\n  observers: Array&#x3C;Observer>;\n  video: Video;\n\n  constructor() {\n    this.observers = [];\n    this.video = { title: 'init' };\n  }\n\n  registerObserver(observer: Observer) {\n    this.observers.push(observer);\n  }\n\n  removeObserver(observer: Observer) {\n    const index = this.observers.indexOf(observer);\n    this.observers = this.observers.splice(index, 1);\n  }\n\n  notifyObservers() {\n    this.observers.forEach(observer => {\n      observer.update(this.video);\n    });\n  }\n\n  setVideo() {\n    this.video = { title: new Date().getTime().toString()};\n    this.notifyObservers();\n  }\n}\n</code></pre>\n<ul>\n<li>User</li>\n</ul>\n<pre><code class=\"language-typescript\">class User implements Observer {\n  subject: Subject;\n  constructor(subject: Subject) {\n    this.subject = subject;\n    this.subject.registerObserver(this);\n  }\n\n  update(video: Video) {\n    this.display(video);\n  }\n\n  unsubscribe() {\n    this.subject.removeObserver(this);\n  }\n\n  display(video: Video) {\n    console.log('video:' + video.title);\n  }\n}\n</code></pre>\n<ul>\n<li>Main</li>\n</ul>\n<pre><code class=\"language-typescript\">const youtuber = new Youtuber();\nconst user = new User(youtuber);\nconst user2 = new User(youtuber);\nconst user3 = new User(youtuber);\nyoutuber.setVideo();\n\nuser2.unsubscribe();\nconsole.log('user2 unsubscribe');\nuser3.unsubscribe();\nconsole.log('user3 unsubscribe');\nyoutuber.setVideo();\n</code></pre>\n<ul>\n<li>Result</li>\n</ul>\n<pre><code class=\"language-typescript\">TypeScript v3.3.3 linux/amd64\nvideo:1563710179580\nvideo:1563710179580\nvideo:1563710179580\nuser2 unsubscribe\nuser3 unsubscribe\nvideo:1563710179581\n</code></pre>\n<ul>\n<li>可以由結果看到一開始使用者都訂閱了youtuber, 所以當youtuber上架新影片時(<code>youtuber.setVideo()</code>), 三個user都收到了通知(<code>video:1563710179580</code>), 接著user2, user3退訂了之後, youtuber就只發通知給訂閱中(沒退訂)的user而已</li>\n</ul>\n<h2>優點</h2>\n<ul>\n<li>完美的切割程式碼中會變動的部分，將固定與會變動的部分分開</li>\n<li>定義了通知的傳遞機制</li>\n<li>讓物件與物件間達到鬆散 (loose coupling)</li>\n</ul>\n<h2>結論</h2>\n<ul>\n<li>我們這次介紹的是Push Model，另外還有Pull Model下次有時間再介紹，但基本上概念是相同的，差別僅在於Observer讀取的方式而已。</li>\n</ul>\n<h3>Source Code</h3>\n<p><a href=\"https://github.com/YiTingLee/Design-Pattern/blob/main/observer-pattern/index.ts\">https://github.com/YiTingLee/Design-Pattern/blob/main/observer-pattern/index.ts</a></p>","fields":{"slug":"/posts/design-pattern-observer-pattern","tagSlugs":["/tag/design-pattern/"],"readingTime":{"text":"3 min read"}},"frontmatter":{"date":"2020-10-08T14:35:00.000Z","description":"Rxjs是什麼設計模式?","tags":["Design Pattern"],"title":"Observer Pattern","socialImage":""}}},"pageContext":{"slug":"/posts/design-pattern-observer-pattern"}},"staticQueryHashes":["251939775","3688386433","401334301"]}