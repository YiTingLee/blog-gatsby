{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/row-column-database-intro","result":{"data":{"markdownRemark":{"id":"5f434840-009b-5fa2-82c7-a83324de180d","html":"<p>在這篇文章中我們會聊到</p>\n<ul>\n<li>什麼是 Row-oriented Database</li>\n<li>什麼是 Column-oriented Database</li>\n<li>Row-oriented Database 的使用場景</li>\n<li>Column-oriented Database 的使用場景</li>\n<li>Postgres 內使用 Columnar index</li>\n</ul>\n<h2 id=\"什麼是-row-oriented-database\" style=\"position:relative;\"><a href=\"#%E4%BB%80%E9%BA%BC%E6%98%AF-row-oriented-database\" aria-label=\"什麼是 row oriented database permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什麼是 Row-oriented Database</h2>\n<p>我們常使用的 DBMS 如 MySQL/PostgreSQL/MSSQL 都是屬於 Row-oriented DBMS，顧名思義這些資料庫在儲存資料時都是把資料依 Record(所有 column) 視為一筆資料，並把這筆資料依照順序儲存在一起。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 560px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fbb1c8ba17e0434c997c4e0da01dca96/b06ae/row-oriented.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABYUlEQVQY022QXW+UQBhG+YVeeeG118Y7458yGhMTm3Sta9TEtHX75bIUFtrtwMICMwM7lIWl7ZHS9q6TnDxP8iZnZl5r7Lzn69lrRvZbPv19yWj2hrHzjs9Hr/hw+IKL9Bv3Z9t17J8t2PvjcBoo/LRjHrfMkwfcZUMkW6wr+RP76gt+/B2hf3DsfcQN9wiLXwTpLrq6HIRVc8Pk1MHzPHKpUbpEqmJIpYu+lzhijSVNQJhOEbFD1cYEYsIimvaChLIWVBvJ3e0dhdmQa0NdrdFKorVEqZyy6OUywxiDFxmsVTEjzE4QyT+KOiCIDoZe1peoao4qQ7I0I850f7FBmwa1fuCpF6Yl0zXnYS/UZkG4mrFc+bS3/W4WR4ilS93mwyvrRg9fNpsOO2qxw+dohpmXbLFEfoArxtjBmKU+xL4YMZnu4Ee/idQ+5XU0CNvuBn+1xY17ksd85F503mcot/wH1YW3fS3fqHQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/fbb1c8ba17e0434c997c4e0da01dca96/8ac56/row-oriented.webp 240w,\n/static/fbb1c8ba17e0434c997c4e0da01dca96/d3be9/row-oriented.webp 480w,\n/static/fbb1c8ba17e0434c997c4e0da01dca96/ac282/row-oriented.webp 560w\"\n              sizes=\"(max-width: 560px) 100vw, 560px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/fbb1c8ba17e0434c997c4e0da01dca96/8ff5a/row-oriented.png 240w,\n/static/fbb1c8ba17e0434c997c4e0da01dca96/e85cb/row-oriented.png 480w,\n/static/fbb1c8ba17e0434c997c4e0da01dca96/b06ae/row-oriented.png 560w\"\n            sizes=\"(max-width: 560px) 100vw, 560px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/fbb1c8ba17e0434c997c4e0da01dca96/b06ae/row-oriented.png\"\n            alt=\"Row-oriented\"\n            title=\"Row-oriented\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>row-oriented 儲存方式的優點包含</p>\n<ul>\n<li>適合擁有大量寫入需求的場景：想像一下當今天有一筆或多筆新的資料要寫入資料庫時，只要找到 Table 儲存資料的位置並把資料塞在最後面即可。</li>\n<li>適合取整筆資料：因為資料都是以一整筆一整筆的方式儲存再一起，取得時候也只要去同一個地方就可以把整筆資料拉出來。</li>\n</ul>\n<p>缺點並不難想像，因為這種儲存方式，當資料庫在搜尋某筆資料或計算某個欄位時，資料庫會把所有欄位都放到記憶體內，因此造成了許多不必要的資源浪費。舉個例，下面兩個 Query 在 Row-oriented database 是沒有差別的，因為資料庫在計算時都會把該筆的所有欄位都一併放到記憶體內。</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-sql line-numbers\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> id <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> user_id <span class=\"token operator\">=</span> <span class=\"token string\">'...'</span><span class=\"token punctuation\">;</span>\nvs\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> user_id <span class=\"token operator\">=</span> <span class=\"token string\">'...'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<h2 id=\"什麼是-column-oriented-database\" style=\"position:relative;\"><a href=\"#%E4%BB%80%E9%BA%BC%E6%98%AF-column-oriented-database\" aria-label=\"什麼是 column oriented database permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什麼是 Column-oriented Database</h2>\n<p>Column-oriented Database 也有人稱它為 Columnar Database，常見的資料庫有 AWS 版的 RedShift，GCP 版的 BigQuery，以及 Open Source 版的 ClickHouse 等。Column-oriented 資料庫也完全支援 SQL 語法，如果沒有研究他們的底層差異，Query 資料時可能不會感覺到有什麼不同。</p>\n<p>Column-oriented 與 Row-oriented 的資料庫之間最大差異就是儲存方式完全相反。如下圖所示，Column-oriented DMBS 儲存時是將所有的 Column 都分開來看，並分別把 Column 儲存在檔案系統內不同的地方。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 559px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c27fb909eda01a2394145b2a0d074c12/a65ce/column-oriented.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30.41666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZ0lEQVQY022RzWrbUBBG/XJdZ9llH6BZBfpO3RS6aCAtTloIuMV2Gyex40hWpFzp6krWnyVkW5Jlc3Kj0EKgAx8zmzkz30zv+/wDpzfv+DY75tP4SOf3XMxP+PznLR+Hb3Cic56jaVsGkwe+nI+4MkLsqMVUW8ygYRHudN7hJTt6ajXE8L4i4gEqHzBzzrDVJWExQqQ/KDayA26aA5OpiRCCIFySZrlWhinXGOEBI9h30F5WOshoihvcUdYejpzwKKeUlSLfPlJuE5q6IV/XzBcunh8QJSviVCvRQP8vsO027S1X99j+EEuMyasHDOenrn9TaFi6NklznziKkUGMYStMy2FhCy2XZfwfYLFRhImlGyX1PsEPTaLUpdqttM2Iqik6y+v6wPXMYnJ9g3B9bMdF+gpLbV5blsmYe9FnavX1DUfM7D6j21MW3iUy+8XzwJen7HGXJZaXYIq4ky0zrKDSm7X/nvIETZ60Wo/PEVYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/c27fb909eda01a2394145b2a0d074c12/8ac56/column-oriented.webp 240w,\n/static/c27fb909eda01a2394145b2a0d074c12/d3be9/column-oriented.webp 480w,\n/static/c27fb909eda01a2394145b2a0d074c12/9f71c/column-oriented.webp 559w\"\n              sizes=\"(max-width: 559px) 100vw, 559px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/c27fb909eda01a2394145b2a0d074c12/8ff5a/column-oriented.png 240w,\n/static/c27fb909eda01a2394145b2a0d074c12/e85cb/column-oriented.png 480w,\n/static/c27fb909eda01a2394145b2a0d074c12/a65ce/column-oriented.png 559w\"\n            sizes=\"(max-width: 559px) 100vw, 559px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/c27fb909eda01a2394145b2a0d074c12/a65ce/column-oriented.png\"\n            alt=\"Column-oriented\"\n            title=\"Column-oriented\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>column-oriented 儲存方式優點包含</p>\n<ul>\n<li>適合壓縮(檔案較小)：由於已經根據 Column 把不同資料型態的資料都分開來儲存及處理，這代表著每次儲存前的壓縮都只需要處理相近的資料格式，這種特性對於資料壓縮是非常有效果的。(舉個例子，大多的壓縮方式如 Huffman Coding 在編碼前都會先計算該文字出現的次數來壓縮，這意味著出現越多次的資料可以被壓縮的碼數更少，也就是說資料越分歧壓縮比就會越差）</li>\n<li>適合億級資料計算：計算 sum/min/max 時 column-oriented DB 只會把該 query 內的條件 column 拿出來計算，這聽起來很合理，但如上面所說，row-oriented DB 並不是這樣運作，它會把所有”COLUMN”都掃過一遍，所以大大增加了許多 IO 的負擔。這樣的特性在資料量越大的時候感受會越明顯。</li>\n<li>適合資料區間搜尋：例如搜尋某個日期或某個月份的所有資料。</li>\n</ul>\n<p>目前聽起來 Column-oriented Database 好像很厲害，又快資料量又小，但 Column-oriented DB 也是有缺點的，缺點如下</p>\n<ul>\n<li>不適合大量寫入：想下一下，每次有資料要寫入時，都要去找到所有 column 的儲存位置，把資料放進去並重新壓縮再存回去，遠低於 row-oriented 的效率。而且很明顯的 table 的 column 數量會影響寫入速度。</li>\n<li>資料量小的時候明顯的效能差異</li>\n</ul>\n<h2 id=\"row-oriented-database-的使用場景\" style=\"position:relative;\"><a href=\"#row-oriented-database-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A0%B4%E6%99%AF\" aria-label=\"row oriented database 的使用場景 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Row-oriented Database 的使用場景</h2>\n<p>目前絕大多數的 App 場景都是比較適合 Row-oriented Database 的。例如我們可能需要在 users 的 Table 中找到某一個位使用者的所有資料來組成 user profile 的頁面。該場景在搭配 Index 的使用後效能表現是非常優秀的，這樣的工作就不太適合使用 Column-oriented DB 來處理。</p>\n<h2 id=\"column-oriented-database-的使用場景\" style=\"position:relative;\"><a href=\"#column-oriented-database-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A0%B4%E6%99%AF\" aria-label=\"column oriented database 的使用場景 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Column-oriented Database 的使用場景</h2>\n<p>Column-oriented Database 更適合用於處理大數據及 BI 等資料分析相關的運算，由於這些場景有一個共通的特性就是要針對某個或某些 Column 進行大量的分析，不需要把所有的 Column 都拉出來跑過一遍。</p>\n<p>另外也可以把 Row-oriented DB 內的不太會被更動的靜態歷史資料搬到 Column-oriented DB 進行儲存，會省下許多的資料空間，並且未來也容易拿來進行資料的分析。</p>\n<h2 id=\"怎麼這麼複雜有沒有兩種特性全都要的資料庫\" style=\"position:relative;\"><a href=\"#%E6%80%8E%E9%BA%BC%E9%80%99%E9%BA%BC%E8%A4%87%E9%9B%9C%E6%9C%89%E6%B2%92%E6%9C%89%E5%85%A9%E7%A8%AE%E7%89%B9%E6%80%A7%E5%85%A8%E9%83%BD%E8%A6%81%E7%9A%84%E8%B3%87%E6%96%99%E5%BA%AB\" aria-label=\"怎麼這麼複雜有沒有兩種特性全都要的資料庫 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>怎麼這麼複雜，有沒有兩種特性全都要的資料庫</h2>\n<p>有的，MSSQL 早在 2012 年就導入了 columnstore index，也就是說如果對該 Table 下了這種 index 的話，這個 Table 就會以 column-oriented 的方式去做儲存，但有一個非常不便的缺點是下了該 index 後資料表就會變成 read-only, 不能進行更新或刪除資料的動作。</p>\n<p>Postgres 的部分也有許多 Open Source 在開發相關的 Extension, 如<a href=\"https://github.com/greenplum-db/postgres/tree/zedstore\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Zedstore</a>及<a href=\"https://github.com/citusdata/cstore_fdw\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">cstore_fdw</a>等，另外 Swarm64 DA 也有出付費版的 columnstore index。</p>\n<h2 id=\"結論\" style=\"position:relative;\"><a href=\"#%E7%B5%90%E8%AB%96\" aria-label=\"結論 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>結論</h2>\n<p>資料庫的選擇上與架構設計息息相關，況且資料庫也不是只有這兩種類型，還有 In-memory DB，time-series DB，NOSQL DB 等，與其硬要選一個來作為資料庫使用的話，我們應該要了解每種資料庫的使用場景，並依照不同的情境混合使用。</p>\n<p>在一個大型系統中 Row-oriented DB 進行 OLTP 的相關操作，而 Column-oriented DB 就負責 OLAP 的相關操作，In-memory DB 負責處理 Cache 相關的操作等，這才是常見的架構設計模式。各自把自己的優點發揮出來，才能把效能最大化！</p>","fields":{"slug":"/posts/row-column-database-intro","tagSlugs":["/tag/database/","/tag/optimization/"],"readingTime":{"text":"8 min read"}},"frontmatter":{"date":"2022-04-06T21:00:00.000+0800","description":"聊聊Row-oriented與Column-oriented的介紹與使用場景","tags":["Database","Optimization"],"title":"Row-oriented vs Column-oriented Database","socialImage":""}}},"pageContext":{"slug":"/posts/row-column-database-intro"}},"staticQueryHashes":["251939775","3688386433","401334301"]}