{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/docker-image-minimization","result":{"data":{"markdownRemark":{"id":"25efa116-eceb-51a7-8334-08c5b82b80dd","html":"<h2>介紹</h2>\n<p>在上傳或下載 docker image 的時候，大家或多或少都應該有遇過 Timeout 或是上傳速度很慢等問題，更甚至有時候是把 docker image 拉到 IOT 裝置上面跑，先天條件上機器就無法容納沒減肥過的 docker image，而縮小 docker image 的大小是避免這些問題的方法之一，也是我們今天要做的主要實驗。</p>\n<p>今天的實驗主要是使用 Nest 這個框架建立出來的 service 來做為我們縮小的主要對象。雖然是使用 Nest 作為範例，但這些方法和概念都可以適用在不同的專案上。</p>\n<h2>第一輪: 準備</h2>\n<p>用 Nest 建一個基本的專案吧</p>\n<pre><code class=\"language-shell\">$ nest new nest-playground\n</code></pre>\n<p>我們會得到一個完整 Nest 的 App, 看起會像這樣\n<img src=\"/images/docker-image-minimization/folder-structure.png\" alt=\"Folder Structure\"></p>\n<p>接著用最基本的方法包成 docker image 吧</p>\n<ul>\n<li>nest-playground 的專案下建立 Dockerfile</li>\n</ul>\n<pre><code class=\"language-Dockerfile\">FROM node:12\n\nWORKDIR /app\n\nCOPY . .\n\nRUN yarn install\n\nEXPOSE 3000\n\nCMD [\"yarn\", \"start\"]\n</code></pre>\n<ul>\n<li>build docker image 指令如下</li>\n</ul>\n<pre><code class=\"language-shell\">$ docker build -t nest-backend .\n</code></pre>\n<p>這樣 build 出來的 docker-image 總共使用了*<strong>*1.6G**</strong>，比預想中大很多吧</p>\n<h4>為什麼這麼大?</h4>\n<p>因為我們把整個 repo，node_modules，以及實際 build 出來的 js 都包在這包 image 內了</p>\n<h2>第二輪: 拿掉非必要檔案</h2>\n<h4>那怎麼辦?</h4>\n<p>這邊先把必要的程式留下來，其他非必要的檔案都拿掉，包含 source code，也就是說除了 build 出來的 dist 外其他檔案都不需要存在</p>\n<ul>\n<li>\n<p>把 Dockerfile 分成兩個 stage</p>\n<ul>\n<li>stage1 負責 build code</li>\n<li>stage2 則負責把 stage1 build 好的程式 copy 進去 stage2 內然後 run 起來</li>\n</ul>\n</li>\n</ul>\n<p>經過這些處理後，stage2(也就最後要 run 起的 image)內只會包含 dist 內容，任何 repo 內的資料都會被留在 stage1 裡面，並不會被放到 stage2 內，實作如下。</p>\n<pre><code class=\"language-Dockerfile\"># STAGE 1\n\nFROM node:12 AS build\n\nWORKDIR /app\n\nCOPY . .\n\nRUN yarn install\n\nCMD [\"yarn\", \"build:prod\"]\n\n# STAGE 2\n\nFROM node:12\n\nWORKDIR /app\n\nCOPY --from=build /app/package.json .\nCOPY --from=build /app/dist ./dist\n\nEXPOSE 3000\n\nCMD [\"yarn\", \"start:prod\"]\n</code></pre>\n<p>這邊為了將 node_modules 內沒使用到的東西拿掉，我們使用了 webpack 來處理，<a href=\"https://github.com/YiTingLee/NestAppMinimization/blob/master/webpack.config.js\">Webpack Config</a>在這邊。</p>\n<p>這樣處理完的 docker image 剩下*<strong>*919MB**</strong></p>\n<h4>感覺還是很大?</h4>\n<h2>第三輪: 使用輕量化的 Node 版本 alpine</h2>\n<p>我們一般使用的 node image 是 Debian based 的，擁有完整的功能，大小約 650MB+，而 alpine 僅有維持運作最基礎的 OS 功能，甚至連 Python/gcc 都沒有，大小約 50MB+。使用輕量化的 node 並不是完全沒有後遺症，輕量化的 image 肯定就是拿掉了許多功能及 module，但在 image size 上是擁有很大的優勢。</p>\n<pre><code class=\"language-Dockerfile\"># STAGE 1\n\nFROM node:12-alpine AS build\n\nWORKDIR /app\n\nCOPY . .\n\nRUN yarn install\n\nCMD [\"yarn\", \"build:prod\"]\n\n# STAGE 2\n\nFROM node:12-alpine\n\nWORKDIR /app\n\nCOPY --from=build /app/package.json .\nCOPY --from=build /app/dist ./dist\n\nEXPOSE 3000\n\nCMD [\"yarn\", \"start:prod\"]\n</code></pre>\n<p>使用輕量版 Node build 完後的總大小是*<strong>*90.5MB**</strong></p>\n<h2>結論</h2>\n<p>這次的實驗大小的進度分別是 1.6GB -> 919MB -> 90.5MB，總共減少了 17X，當中除了 Dockerfile 在 Stage 上的操作外還有一些 webpack 的使用才能大幅度的減少 image 的大小。</p>\n<p>這邊要再說一次，雖然今天的實驗主要是使用 Nest 這個框架做為我們的主要範例，但這些方法及概念都可以套用到不同的專案上，尤其是 frontend 的專案另外還可以使用 nginx 等輕量化的 web server 作為基底。</p>\n<h2>Source Code</h2>\n<p><a href=\"https://github.com/YiTingLee/NestAppMinimization\">https://github.com/YiTingLee/NestAppMinimization</a></p>","fields":{"slug":"/posts/docker-image-minimization","tagSlugs":["/tag/docker/","/tag/optimization/"],"readingTime":{"text":"5 min read"}},"frontmatter":{"date":"2021-07-17T17:00:00.000Z","description":"Docker image減肥大作戰!!","tags":["Docker","Optimization"],"title":"Docker Image Minimization","socialImage":""}}},"pageContext":{"slug":"/posts/docker-image-minimization"}},"staticQueryHashes":["251939775","3688386433","401334301"]}