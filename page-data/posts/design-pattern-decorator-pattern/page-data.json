{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/design-pattern-decorator-pattern","result":{"data":{"markdownRemark":{"id":"ae9a6199-6d7f-5009-86e9-4673d56e60cf","html":"<h2>介紹</h2>\n<p>現在手搖飲料店開得越來越多，能夠點的手搖種類也相當多元，比方說綠茶珍珠、珍珠奶茶、椰果奶茶、仙草奶綠等等，每種配料都能隨意組合，所以 Post 機上的飲料管理肯定相當複雜，這種情況就非常適合使用裝飾者模式來處理。</p>\n<p>若是直接硬幹的話，通常 Class 會長成 MilkTea、BubbleMilkTea 和 BubbleMilkGreenTea 等等，也就是說只要一種配料搭配一種茶類就必須多一個 Class。再來如果要兩倍珍珠的話，這設計方式只能在遇到需求的時候請程式設計師再加一個 Class，這種設計方式顯然是不好的。</p>\n<p>簡單來說，裝飾者模式把上述配料當作裝飾者，而茶類的本體作為被裝飾者，可以想像成被裝飾者還是飲料的主體，而裝飾者只是在被裝飾者的身上加了某些效果及行為。</p>\n<h2>例子</h2>\n<ul>\n<li>我們模擬上面的例子</li>\n<li>被裝飾者抽象類別: Beverage</li>\n</ul>\n<pre><code class=\"language-typescript\">abstract class Beverage {\n  description!: string;\n\n  abstract getCost(): number;\n\n  getDescription(): string {\n    return this.description;\n  }\n}\n</code></pre>\n<ul>\n<li>各種飲料的實現</li>\n</ul>\n<pre><code class=\"language-typescript\">class MilkTea extends Beverage {\n  constructor() {\n    super();\n    this.description = \"Milk Tea\";\n  }\n\n  getCost() {\n    return 50;\n  }\n}\n\nclass GreenTea extends Beverage {\n  constructor() {\n    super();\n    this.description = \"Green Tea\";\n  }\n\n  getCost() {\n    return 40;\n  }\n}\n</code></pre>\n<ul>\n<li>裝飾者抽象類別: CondimentDecorator</li>\n</ul>\n<pre><code class=\"language-typescript\">abstract class CondimentDecorator extends Beverage {\n  abstract getCost(): number;\n  abstract getDescription(): string;\n}\n</code></pre>\n<ul>\n<li>\n<p>這邊我解釋一下為甚麼<code>getCost</code>和<code>getDescription</code>這兩個方法都必須被重新覆寫</p>\n<ul>\n<li>裝飾者的主要運作方式是在被裝飾者的前後增加某種行為或效果，由下方的 implement 可以看出覆寫後對<code>getCost</code>和<code>getDescription</code>增加的行為。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>各種裝飾者的實現</li>\n</ul>\n<pre><code class=\"language-typescript\">class Bubble extends CondimentDecorator {\n  private beverage: Beverage;\n\n  constructor(beverage: Beverage) {\n    super();\n    this.beverage = beverage;\n  }\n\n  getDescription() {\n    return this.beverage.getDescription() + ', Bubble';\n  }\n\n  getCost() {\n    return this.beverage.getCost() + 10;\n  }\n}\n\nclass Pudding extends CondimentDecorator {\n  private beverage: Beverage;\n\n  constructor(beverage: Beverage) {\n    super();\n    this.beverage = beverage;\n  }\n\n  getDescription() {\n    return this.beverage.getDescription() + ', Pudding';\n  }\n\n  getCost() {\n    return this.beverage.getCost() + 20;\n  }\n}\n</code></pre>\n<ul>\n<li>到目前為止我們主要實現了兩個 GreenTea, MilkTea 這兩個被裝飾者 Class, 和 Bubble, Pudding 兩個裝飾者的 Class。</li>\n</ul>\n<hr>\n<ul>\n<li>Main</li>\n</ul>\n<pre><code class=\"language-typescript\">console.log(\"Start\");\nconst beverage = new MilkTea();\nconsole.log(beverage.getDescription());\nconsole.log(beverage.getCost());\n\nconst bubbleMilkTea = new Bubble(new MilkTea());\nconsole.log(bubbleMilkTea.getDescription());\nconsole.log(bubbleMilkTea.getCost());\n\nconst powerTea = new Pudding(new Bubble(new Bubble(new MilkTea())));\nconsole.log(powerTea.getDescription());\nconsole.log(powerTea.getCost());\n</code></pre>\n<ul>\n<li>Result</li>\n</ul>\n<pre><code class=\"language-typescript\">TypeScript v3.3.3 Node.js v10 linux/amd64\nStart\nMilk Tea\n50\nMilk Tea, Bubble\n60\nMilk Tea, Bubble, Bubble, Pudding\n90\n</code></pre>\n<ul>\n<li>可以由 Main 程式中看出裝飾者與被裝飾者如何合作</li>\n<li>裝飾者做的事就是直接在被裝飾者身上加行為(不管裝飾者現在到底長怎樣)</li>\n</ul>\n<h2>優點</h2>\n<ul>\n<li>高彈性</li>\n<li>達到物件與物件間鬆綁的效果</li>\n<li>於程式執行期中使用合成來達到效果，而非編譯期達成。</li>\n</ul>\n<h2>缺點</h2>\n<ul>\n<li>裝飾者的小類別會非常多</li>\n<li>初學者會認為相對複雜，容易迷失在物件與物件之間的關係。</li>\n</ul>\n<h2>結論</h2>\n<p>裝飾者模式的優缺點都相對明顯，若使用不當容易造成程式複雜且難以維護，但許多的程式 Library 中都能夠看到使用裝飾者模式的身影。</p>\n<h3>Source Code</h3>\n<p><a href=\"https://github.com/YiTingLee/Design-Pattern/blob/main/decorator-pattern/index.ts\">https://github.com/YiTingLee/Design-Pattern/blob/main/decorator-pattern/index.ts</a></p>","fields":{"slug":"/posts/design-pattern-decorator-pattern","tagSlugs":["/tag/design-pattern/"],"readingTime":{"text":"4 min read"}},"frontmatter":{"date":"2020-11-07T23:15:00.000Z","description":"簡單的飲料例子來解釋Decorator","tags":["Design Pattern"],"title":"Decorator Pattern","socialImage":""}}},"pageContext":{"slug":"/posts/design-pattern-decorator-pattern"}},"staticQueryHashes":["251939775","3688386433","401334301"]}